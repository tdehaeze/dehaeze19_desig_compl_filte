#+TITLE: On the Design of Complementary Filters for Control - Computation with Matlab
:DRAWER:
#+HTML_LINK_HOME: ../index.html
#+HTML_LINK_UP: ../index.html

#+LATEX_CLASS: cleanreport
#+LATEX_CLASS_OPTIONS: [tocnp, secbreak, minted]

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/readtheorg.css"/>
#+HTML_HEAD: <script src="../js/jquery.min.js"></script>
#+HTML_HEAD: <script src="../js/bootstrap.min.js"></script>
#+HTML_HEAD: <script src="../js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script src="../js/readtheorg.js"></script>

#+PROPERTY: header-args:matlab  :session *MATLAB*
#+PROPERTY: header-args:matlab+ :tangle matlab/comp_filters_design.m
#+PROPERTY: header-args:matlab+ :comments org
#+PROPERTY: header-args:matlab+ :exports both
#+PROPERTY: header-args:matlab+ :results none
#+PROPERTY: header-args:matlab+ :eval no-export
#+PROPERTY: header-args:matlab+ :noweb yes
#+PROPERTY: header-args:matlab+ :mkdirp yes
#+PROPERTY: header-args:matlab+ :output-dir figs
:END:

* Introduction                                                       :ignore:
In this document, the design of complementary filters is studied.

One use of complementary filter is described below:
#+begin_quote
  The basic idea of a complementary filter involves taking two or more sensors, filtering out unreliable frequencies for each sensor, and combining the filtered outputs to get a better estimate throughout the entire bandwidth of the system.
  To achieve this, the sensors included in the filter should complement one another by performing better over specific parts of the system bandwidth.
#+end_quote

- in section [[sec:optimal_comp_filters]], the optimal design of the complementary filters in order to obtain the lowest resulting "super sensor" noise is studied

When blending two sensors using complementary filters with unknown dynamics, phase lag may be introduced that renders the close-loop system unstable.
- in section [[sec:comp_filter_robustness]], the blending robustness to sensor dynamic uncertainty is studied.

Then, three design methods for generating two complementary filters are proposed:
- in section [[sec:comp_filters_analytical]], analytical formulas are proposed
- in section [[sec:h_inf_synthesis_complementary_filters]], the $\mathcal{H}_\infty$ synthesis is used
- in section [[sec:feedback_generate_comp_filters]], the classical feedback architecture is used
- in section [[sec:three_comp_filters]], a method using the $\mathcal{H}_\infty$ synthesis is proposed to shape three of more complementary filters

Finally:
- in section [[sec:comp_filters_ligo]], some design methods are used and compared with FIR complementary filters used for LIGO
- in section [[sec:analytical_formula_literature]], analytical formulas found in the literature are listed
- in section [[sec:discussion]], we discuss the findings

* Optimal Sensor Fusion for noise characteristics
  :PROPERTIES:
  :header-args:matlab+: :tangle matlab/optimal_comp_filters.m
  :header-args:matlab+: :comments org :mkdirp yes
  :END:
  <<sec:optimal_comp_filters>>

** Introduction                                                      :ignore:
The idea is to combine sensors that works in different frequency range using complementary filters.

Doing so, one "super sensor" is obtained that can have better noise characteristics than the individual sensors over a large frequency range.

The complementary filters have to be designed in order to minimize the effect noise of each sensor on the super sensor noise.

** ZIP file containing the data and matlab files                     :ignore:
#+begin_src bash :exports none :results none
  if [ matlab/optimal_comp_filters.m -nt data/optimal_comp_filters.zip ]; then
    cp matlab/optimal_comp_filters.m optimal_comp_filters.m;
    zip data/optimal_comp_filters \
        optimal_comp_filters.m
    rm optimal_comp_filters.m;
  fi
#+end_src

#+begin_note
  All the files (data and Matlab scripts) are accessible [[file:data/optimal_comp_filters.zip][here]].
#+end_note

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab
  freqs = logspace(-1, 3, 1000);
#+end_src

** Architecture
Let's consider the sensor fusion architecture shown on figure [[fig:fusion_two_noisy_sensors_with_dyn]] where two sensors 1 and 2 are measuring the same quantity $x$ with different noise characteristics determined by $W_1$ and $W_2$.

$n_1$ and $n_2$ are white noise (constant power spectral density over all frequencies).

#+name: fig:fusion_two_noisy_sensors_with_dyn
#+caption: Fusion of two sensors
[[file:figs/fusion_two_noisy_sensors_with_dyn.png]]

We consider that the two sensor dynamics $G_1$ and $G_2$ are ideal ($G_1 = G_2 = 1$). We obtain the architecture of figure [[fig:fusion_two_noisy_sensors]].

#+name: fig:fusion_two_noisy_sensors
#+caption: Fusion of two sensors with ideal dynamics
[[file:figs/fusion_two_noisy_sensors.png]]

$H_1$ and $H_2$ are complementary filters ($H_1 + H_2 = 1$). The goal is to design $H_1$ and $H_2$ such that the effect of the noise sources $n_1$ and $n_2$ has the smallest possible effect on the estimation $\hat{x}$.

We have that the Power Spectral Density (PSD) of $\hat{x}$ is:
\[ \Gamma_{\hat{x}} = |H_1 W_1|^2 \Gamma_{n_1} + |H_2 W_2|^2 \Gamma_{n_2} \]

And the goal is the minimize the Root Mean Square (RMS) value of $\hat{x}$:
\[ \sigma_{\hat{x}} = \sqrt{\int_0^\infty \Gamma_{\hat{x}}(\omega) d\omega} \]

As $n_1$ and $n_2$ are white noise: $\Gamma_{n_1} = \Gamma_{n_2} = 1$ and we have:
\[ \sigma_{\hat{x}} = \sqrt{\int_0^\infty |H_1 W_1|^2(\omega) + |H_2 W_2|^2(\omega) d\omega} = \left\| \begin{matrix} H_1 W_1 \\ H_2 W_2 \end{matrix} \right\|_2 \]

Thus, the goal is to design $H_1$ and $H_2$ such that $H_1 + H_2 = 1$ and such that $\left\| \begin{matrix} H_1 W_1 \\ H_2 W_2 \end{matrix} \right\|_2$ is minimized.

For that, we will use the $\mathcal{H}_2$ Synthesis.

** Noise of the sensors
Let's define the noise characteristics of the two sensors by choosing $W_1$ and $W_2$:
- Sensor 1 characterized by $W_1$ has low noise at low frequency (for instance a geophone)
- Sensor 2 characterized by $W_2$ has low noise at high frequency (for instance an accelerometer)

#+begin_src matlab :exports none
  omegac = 2*pi; G0 = 1e-2; Ginf = 1e-6;
  W1 = ((sqrt(G0))/(s/omegac + 1))^2;

  omegac = 100*2*pi; G0 = 1e-6; Ginf = 1e-2;
  W2 = ((sqrt(Ginf)*s/omegac + sqrt(G0))/(s/omegac + 1))^2/(1 + s/2/pi/4000)^2;
#+end_src

#+begin_src matlab
  omegac = 100*2*pi; G0 = 1e-5; Ginf = 1e-4;
  W1 = (Ginf*s/omegac + G0)/(s/omegac + 1)/(1 + s/2/pi/4000);

  omegac = 1*2*pi; G0 = 1e-3; Ginf = 1e-8;
  W2 = ((sqrt(Ginf)*s/omegac + sqrt(G0))/(s/omegac + 1))^2/(1 + s/2/pi/4000)^2;
#+end_src

#+begin_src matlab :exports none
  figure;
  hold on;
  plot(freqs, abs(squeeze(freqresp(W1, freqs, 'Hz'))), '-', 'DisplayName', '$W_1$');
  plot(freqs, abs(squeeze(freqresp(W2, freqs, 'Hz'))), '-', 'DisplayName', '$W_2$');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('Magnitude');
  hold off;
  xlim([freqs(1), freqs(end)]);
  legend('location', 'northeast');
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/nosie_characteristics_sensors.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:nosie_characteristics_sensors
#+CAPTION: Noise Characteristics of the two sensors ([[./figs/nosie_characteristics_sensors.png][png]], [[./figs/nosie_characteristics_sensors.pdf][pdf]])
[[file:figs/nosie_characteristics_sensors.png]]

** H-Two Synthesis
We use the generalized plant architecture shown on figure [[fig:h_infinity_optimal_comp_filters]].

#+name: fig:h_infinity_optimal_comp_filters
#+caption: $\mathcal{H}_2$ Synthesis - Generalized plant used for the optimal generation of complementary filters
[[file:figs/h_infinity_optimal_comp_filters.png]]

The transfer function from $[n_1, n_2]$ to $\hat{x}$ is:
\[ \begin{bmatrix} W_1 H_1 \\ W_2 (1 - H_1) \end{bmatrix} \]
If we define $H_2 = 1 - H_1$, we obtain:
\[ \begin{bmatrix} W_1 H_1 \\ W_2 H_2 \end{bmatrix} \]

Thus, if we minimize the $\mathcal{H}_2$ norm of this transfer function, we minimize the RMS value of $\hat{x}$.

We define the generalized plant $P$ on matlab as shown on figure [[fig:h_infinity_optimal_comp_filters]].
#+begin_src matlab
  P = [0   W2  1;
       W1 -W2  0];
#+end_src

And we do the $\mathcal{H}_2$ synthesis using the =h2syn= command.
#+begin_src matlab
  [H1, ~, gamma] = h2syn(P, 1, 1);
#+end_src

What is minimized is =norm([W1*H1,W2*H2], 2)=.

Finally, we define $H_2 = 1 - H_1$.
#+begin_src matlab
  H2 = 1 - H1;
#+end_src

** Analysis
The complementary filters obtained are shown on figure [[fig:htwo_comp_filters]]. The PSD of the [[fig:psd_sensors_htwo_synthesis]].
Finally, the RMS value of $\hat{x}$ is shown on table [[tab:rms_results]].
The optimal sensor fusion has permitted to reduced the RMS value of the estimation error by a factor 8 compare to when using only one sensor.

#+begin_src matlab :exports none
  figure;
  hold on;
  plot(freqs, abs(squeeze(freqresp(H1, freqs, 'Hz'))), '-', 'DisplayName', '$H_1$');
  plot(freqs, abs(squeeze(freqresp(H2, freqs, 'Hz'))), '-', 'DisplayName', '$H_2$');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('Magnitude');
  hold off;
  xlim([freqs(1), freqs(end)]);
  legend('location', 'northeast');
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/htwo_comp_filters.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:htwo_comp_filters
#+CAPTION: Obtained complementary filters using the $\mathcal{H}_2$ Synthesis ([[./figs/htwo_comp_filters.png][png]], [[./figs/htwo_comp_filters.pdf][pdf]])
[[file:figs/htwo_comp_filters.png]]

#+begin_src matlab :exports none
  figure;
  hold on;
  plot(freqs, abs(squeeze(freqresp(W1, freqs, 'Hz'))).^2, '-',  'DisplayName', '$|W_1|^2$');
  plot(freqs, abs(squeeze(freqresp(W2, freqs, 'Hz'))).^2, '-',  'DisplayName', '$|W_2|^2$');
  plot(freqs, abs(squeeze(freqresp(W1*H1, freqs, 'Hz'))).^2+abs(squeeze(freqresp(W2*H2, freqs, 'Hz'))).^2, 'k-', 'DisplayName', '$|W_1H_1|^2+|W_2H_2|^2$');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('Magnitude');
  hold off;
  xlim([freqs(1), freqs(end)]);
  legend('location', 'northeast');
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/psd_sensors_htwo_synthesis.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:psd_sensors_htwo_synthesis
#+CAPTION: Power Spectral Density of the estimated $\hat{x}$ using the two sensors alone and using the optimally fused signal ([[./figs/psd_sensors_htwo_synthesis.png][png]], [[./figs/psd_sensors_htwo_synthesis.pdf][pdf]])
[[file:figs/psd_sensors_htwo_synthesis.png]]

#+begin_src matlab :exports results :results value table replace :tangle no :post addhdr(*this*)
  data2orgtable([norm([W1], 2);norm([W2], 2);norm([W1*H1 + W2*H2], 2)], {'Sensor 1', 'Sensor 2', 'Optimal Sensor Fusion'}, {'rms value'}, ' %.1e');
#+end_src

#+name: tab:rms_results
#+caption: RMS value of the estimation error when using the sensor individually and when using the two sensor merged using the optimal complementary filters
#+RESULTS:
|                       | rms value |
|-----------------------+-----------|
| Sensor 1              |   1.1e-02 |
| Sensor 2              |   1.3e-03 |
| Optimal Sensor Fusion |   1.5e-04 |
* Robustness to sensor dynamics uncertainty
  :PROPERTIES:
  :header-args:matlab+: :tangle matlab/comp_filter_robustness.m
  :header-args:matlab+: :comments org :mkdirp yes
  :END:
  <<sec:comp_filter_robustness>>

** Introduction                                                      :ignore:
Let's first consider ideal sensors where $G_1 = 1$ and $G_2 = 1$ (figure [[fig:fusion_two_noisy_sensors_with_dyn_bis]]).

#+name: fig:fusion_two_noisy_sensors_with_dyn_bis
#+caption: Fusion of two sensors
[[file:figs/fusion_two_noisy_sensors_with_dyn_bis.png]]

# #+name: fig:fusion_two_signals
# #+caption: Fusion of two noisy measurements of $x$
# [[file:figs/fusion_two_signals.png]]

We then have:
\begin{align*}
  \hat{x} &= (x + n_1) H_1 + (x + n_2) H_2 \\
          &= x + n_1 H_1 + n_2 H_2
\end{align*}

So the estimation error is
\[ \delta_x = \hat{x} - x = n_1 H_1 + n_2 H_2 \]

And we see that the complementary filters are only shaping the noise and that they do not impact the transfer function from $x$ to $\hat{x}$ that is in the feedback path.

** ZIP file containing the data and matlab files                     :ignore:
#+begin_src bash :exports none :results none
  if [ matlab/comp_filter_robustness.m -nt data/comp_filter_robustness.zip ]; then
    cp matlab/comp_filter_robustness.m comp_filter_robustness.m;
    zip data/comp_filter_robustness \
        comp_filter_robustness.m
    rm comp_filter_robustness.m;
  fi
#+end_src

#+begin_note
  All the files (data and Matlab scripts) are accessible [[file:data/comp_filter_robustness.zip][here]].
#+end_note

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

** Static Gain Mismatch                                            :noexport:
Even though we here still consider that the two sensors have perfect dynamics, we consider gain mismatch for the two sensors:
\begin{align*}
  G_1(s) &= 1 + \delta_1(s) \\
  G_2(s) &= 1 + \delta_2(s)
\end{align*}

Thus, we have:
\begin{align*}
  \hat{x} &= (x + n_1) (1 + \delta_1) H_1 + (x + n_2) (1 + \delta_2) H_2 \\
          &= x (1 + \delta_1 H_1 + \delta_2 H_2) + n_1 (1 + \delta_1) H_1 + n_2(1 + \delta_2)  H_2
\end{align*}

So the transfer function from $x$ to $\hat{x}$ is:
\begin{align*}
  \frac{\hat{x}}{x} &= 1 + \delta_1 H_1 + \delta_2 H_2 \\
                    &= 1 + \delta_1 H_1 + \delta_2 (1 - H_1) \\
                    &= 1 + (\delta_1 - \delta_2) H_1 + \delta_2 \\
\end{align*}

** Unknown sensor dynamics dynamics
In practical systems, the sensor dynamics has always some level of uncertainty.
Let's represent that with multiplicative input uncertainty as shown on figure [[fig:fusion_gain_mismatch]].

#+name: fig:fusion_gain_mismatch
#+caption: Fusion of two sensors with input multiplicative uncertainty
[[file:figs/fusion_gain_mismatch.png]]

We have:
\begin{align*}
  \frac{\hat{x}}{x} &= (1 + W_1 \Delta_1) H_1 + (1 + W_2 \Delta_2) H_2 \\
                    &= 1 + W_1 H_1 \Delta_1 + W_2 H_2 \Delta_2
\end{align*}
With $\Delta_i$ is any transfer function satisfying $\| \Delta_i \|_\infty < 1$.

We see that as soon as we have some uncertainty in the sensor dynamics, we have that the complementary filters have some effect on the transfer function from $x$ to $\hat{x}$.

We want that the super sensor transfer function has a gain of 1 and no phase variation over all the frequencies:
\[ \frac{\hat{x}}{x} \approx 1 \]

Thus, we want that
\begin{align*}
                      & |W_1 H_1 \Delta_1 + W_2 H_2 \Delta_2| < \epsilon \quad \forall \omega,  \forall \Delta_i, \|\Delta_i\|_\infty < 1 \\
  \Longleftrightarrow & |W_1 H_1| + |W_2 H_2| < \epsilon \quad \forall \omega
\end{align*}

Which is approximately the same as requiring
\[ \left\| \begin{matrix} W_1 H_1 \\ W_2 H_2 \end{matrix} \right\|_\infty < \epsilon  \]


*How small should we choose $\epsilon$?*

The uncertainty set of the transfer function from $\hat{x}$ to $x$ is bounded in the complex plane by a circle centered on 1 and with a radius equal to $\epsilon$ (figure [[fig:uncertainty_gain_phase_variation]]).

We then have that the angle introduced by the super sensor is bounded by $\arcsin(\epsilon)$:
\[ \angle \frac{\hat{x}}{x} \le \arcsin (\epsilon) \quad \forall \omega \]

#+name: fig:uncertainty_gain_phase_variation
#+caption: Maximum phase variation
[[file:figs/uncertainty_gain_phase_variation.png]]

Thus, we choose should choose $\epsilon$ so that the maximum phase uncertainty introduced by the sensors is of an acceptable value.

** Design the complementary filters in order to limit the phase and gain uncertainty of the super sensor
Let's say the two sensors dynamics $H_1$ and $H_2$ have been identified with the associated uncertainty weights $W_1$ and $W_2$.

If we want to have a maximum phase introduced by the sensors of 20 degrees, we have to design $H_1$ and $H_2$ such that:
\begin{align*}
                      & arcsin(|H_1 W_1| + |H_2 W_2|) < 20 \text{ deg} \\
  \Longleftrightarrow & |H_1 W_1| + |H_2 W_2| < 0.34
\end{align*}

We can do that with the $\mathcal{H}_\infty$ synthesis by setting upper bounds on the complementary filters using weights that corresponds to the sensor dynamics uncertainty.

For simplicity, let's suppose $W_1(s) = W_2(s) = 0.1$ ($10\%$ uncertainty in the sensor gain).
\[ |H_1 W_1| + |H_2 W_2| < 3.4 \]

Thus, by limiting the norm of the complementary filters, we can limit the maximum unwanted phase introduced by the uncertainty on the sensors dynamics.

This is of primary importance in order to ensure the stability of the feedback loop using the super sensor signal.

** First Basic Example with gain mismatch
Let's consider two ideal sensors except one sensor has not an expected gain of one but a gain of $0.6$.
#+begin_src matlab
  G1 = 1;
  G2 = 0.6;
#+end_src

Let's design two complementary filters as shown on figure [[fig:comp_filters_robustness_test]].
The complementary filters shown in blue does not present a bump as the red ones but provides less sensor separation at high and low frequencies.

#+begin_src matlab :exports none
  w0 = 2*pi;
  alpha = 2;

  H1a = ((1+alpha)*(s/w0)+1)/(((s/w0)+1)*((s/w0)^2 + alpha*(s/w0) + 1));
  H2a = (s/w0)^2*((s/w0)+1+alpha)/(((s/w0)+1)*((s/w0)^2 + alpha*(s/w0) + 1));

  w0 = 2*pi;
  alpha = 0.1;

  H1b = ((1+alpha)*(s/w0)+1)/(((s/w0)+1)*((s/w0)^2 + alpha*(s/w0) + 1));
  H2b = (s/w0)^2*((s/w0)+1+alpha)/(((s/w0)+1)*((s/w0)^2 + alpha*(s/w0) + 1));
#+end_src

#+begin_src matlab :exports none
  freqs = logspace(-1, 1, 1000);

  figure;
  % Magnitude
  ax1 = subaxis(2,1,1);
  hold on;
  set(gca,'ColorOrderIndex',1); plot(freqs, abs(squeeze(freqresp(H1a, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',1); plot(freqs, abs(squeeze(freqresp(H2a, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',2); plot(freqs, abs(squeeze(freqresp(H1b, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',2); plot(freqs, abs(squeeze(freqresp(H2b, freqs, 'Hz'))));
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]);
  ylabel('Magnitude');
  hold off;
  % Phase
  ax2 = subaxis(2,1,2);
  hold on;
  set(gca,'ColorOrderIndex',1); plot(freqs, 180/pi*angle(squeeze(freqresp(H1a, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',1); plot(freqs, 180/pi*angle(squeeze(freqresp(H2a, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',2); plot(freqs, 180/pi*angle(squeeze(freqresp(H1b, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',2); plot(freqs, 180/pi*angle(squeeze(freqresp(H2b, freqs, 'Hz'))));
  set(gca,'xscale','log');
  yticks(-180:90:180);
  ylim([-180 180]);
  xlabel('Relative Frequency $\frac{\omega}{\omega_0}$'); ylabel('Phase [deg]');
  hold off;
  linkaxes([ax1,ax2],'x');
  xlim([freqs(1), freqs(end)]);
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/comp_filters_robustness_test.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:comp_filters_robustness_test
#+CAPTION: The two complementary filters designed for the robustness test ([[./figs/comp_filters_robustness_test.png][png]], [[./figs/comp_filters_robustness_test.pdf][pdf]])
[[file:figs/comp_filters_robustness_test.png]]

We then compute the bode plot of the super sensor transfer function $H_1*G_1 + H_2*G_2$ for both complementary filters pair (figure [[fig:tf_super_sensor_comp]]).

We see that the blue complementary filters with a lower maximum norm permits to limit the phase lag introduced by the gain mismatch.

#+begin_src matlab :exports none
  freqs = logspace(-1, 1, 1000);

  figure;
  % Magnitude
  ax1 = subaxis(2,1,1);
  hold on;
  set(gca,'ColorOrderIndex',1); plot(freqs, abs(squeeze(freqresp(H1a*G1 + H2a*G2, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',2); plot(freqs, abs(squeeze(freqresp(H1b*G1 + H2b*G2, freqs, 'Hz'))));
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]);
  ylabel('Magnitude');
  ylim([1e-1, 1e1]);
  hold off;
  % Phase
  ax2 = subaxis(2,1,2);
  hold on;
  set(gca,'ColorOrderIndex',1); plot(freqs, 180/pi*angle(squeeze(freqresp(H1a*G1 + H2a*G2, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',2); plot(freqs, 180/pi*angle(squeeze(freqresp(H1b*G1 + H2b*G2, freqs, 'Hz'))));
  set(gca,'xscale','log');
  yticks(-180:90:180);
  ylim([-180 180]);
  xlabel('Relative Frequency $\frac{\omega}{\omega_0}$'); ylabel('Phase [deg]');
  hold off;
  linkaxes([ax1,ax2],'x');
  xlim([freqs(1), freqs(end)]);
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/tf_super_sensor_comp.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:tf_super_sensor_comp
#+CAPTION: Comparison of the obtained super sensor transfer functions ([[./figs/tf_super_sensor_comp.png][png]], [[./figs/tf_super_sensor_comp.pdf][pdf]])
[[file:figs/tf_super_sensor_comp.png]]

** TODO More Complete example with model uncertainty
* Complementary filters using analytical formula
  :PROPERTIES:
  :header-args:matlab+: :tangle matlab/comp_filters_analytical.m
  :header-args:matlab+: :comments org :mkdirp yes
  :END:
  <<sec:comp_filters_analytical>>

** Introduction                                                      :ignore:
** ZIP file containing the data and matlab files                     :ignore:
#+begin_src bash :exports none :results none
  if [ matlab/comp_filters_analytical.m -nt data/comp_filters_analytical.zip ]; then
    cp matlab/comp_filters_analytical.m comp_filters_analytical.m;
    zip data/comp_filters_analytical \
        comp_filters_analytical.m
    rm comp_filters_analytical.m;
  fi
#+end_src

#+begin_note
  All the files (data and Matlab scripts) are accessible [[file:data/comp_filters_analytical.zip][here]].
#+end_note

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab
  freqs = logspace(-1, 3, 1000);
#+end_src

** Analytical 1st order complementary filters
First order complementary filters are defined with following equations:
\begin{align}
  H_L(s) = \frac{1}{1 + \frac{s}{\omega_0}}\\
  H_H(s) = \frac{\frac{s}{\omega_0}}{1 + \frac{s}{\omega_0}}
\end{align}

Their bode plot is shown figure [[fig:comp_filter_1st_order]].

#+begin_src matlab
  w0 = 2*pi; % [rad/s]

  Hh1 = (s/w0)/((s/w0)+1);
  Hl1 = 1/((s/w0)+1);
#+end_src

#+begin_src matlab :exports none
  freqs = logspace(-2, 2, 1000);

  figure;
  % Magnitude
  ax1 = subaxis(2,1,1);
  hold on;
  set(gca,'ColorOrderIndex',1); plot(freqs, abs(squeeze(freqresp(Hh1, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',1); plot(freqs, abs(squeeze(freqresp(Hl1, freqs, 'Hz'))));
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]);
  ylabel('Magnitude');
  hold off;
  % Phase
  ax2 = subaxis(2,1,2);
  hold on;
  set(gca,'ColorOrderIndex',1); plot(freqs, 180/pi*angle(squeeze(freqresp(Hh1, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',1); plot(freqs, 180/pi*angle(squeeze(freqresp(Hl1, freqs, 'Hz'))));
  set(gca,'xscale','log');
  yticks(-180:90:180);
  ylim([-180 180]);
  xlabel('Relative Frequency $\frac{\omega}{\omega_0}$'); ylabel('Phase [deg]');
  hold off;
  linkaxes([ax1,ax2],'x');
  xlim([freqs(1), freqs(end)]);
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/comp_filter_1st_order.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:comp_filter_1st_order
#+CAPTION: Bode plot of first order complementary filter ([[./figs/comp_filter_1st_order.png][png]], [[./figs/comp_filter_1st_order.pdf][pdf]])
[[file:figs/comp_filter_1st_order.png]]

** Second Order Complementary Filters
We here use analytical formula for the complementary filters $H_L$ and $H_H$.

The first two formulas that are used to generate complementary filters are:
\begin{align*}
  H_L(s) &= \frac{(1+\alpha) (\frac{s}{\omega_0})+1}{\left((\frac{s}{\omega_0})+1\right) \left((\frac{s}{\omega_0})^2 + \alpha (\frac{s}{\omega_0}) + 1\right)}\\
  H_H(s) &= \frac{(\frac{s}{\omega_0})^2 \left((\frac{s}{\omega_0})+1+\alpha\right)}{\left((\frac{s}{\omega_0})+1\right) \left((\frac{s}{\omega_0})^2 + \alpha (\frac{s}{\omega_0}) + 1\right)}
\end{align*}
where:
- $\omega_0$ is the blending frequency in rad/s.
- $\alpha$ is used to change the shape of the filters:
  - Small values for $\alpha$ will produce high magnitude of the filters $|H_L(j\omega)|$ and $|H_H(j\omega)|$ near $\omega_0$ but smaller value for $|H_L(j\omega)|$ above $\approx 1.5 \omega_0$ and for $|H_H(j\omega)|$ below $\approx 0.7 \omega_0$
  - A large $\alpha$ will do the opposite

This is illustrated on figure [[fig:comp_filters_param_alpha]].
The slope of those filters at high and low frequencies is $-2$ and $2$ respectively for $H_L$ and $H_H$.

#+begin_src matlab :exports none
  freqs_study = logspace(-2, 2, 10000);
  alphas = [0.1, 1, 10];
  w0 = 2*pi*1;

  figure;
  ax1 = subaxis(2,1,1);
  hold on;
  for i = 1:length(alphas)
    alpha = alphas(i);
    Hh2 = (s/w0)^2*((s/w0)+1+alpha)/(((s/w0)+1)*((s/w0)^2 + alpha*(s/w0) + 1));
    Hl2 = ((1+alpha)*(s/w0)+1)/(((s/w0)+1)*((s/w0)^2 + alpha*(s/w0) + 1));
    set(gca,'ColorOrderIndex',i);
    plot(freqs_study, abs(squeeze(freqresp(Hh2, freqs_study, 'Hz'))));
    set(gca,'ColorOrderIndex',i);
    plot(freqs_study, abs(squeeze(freqresp(Hl2, freqs_study, 'Hz'))));
  end
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]);
  ylabel('Magnitude');
  hold off;
  ylim([1e-3, 20]);
  % Phase
  ax2 = subaxis(2,1,2);
  hold on;
  for i = 1:length(alphas)
    alpha = alphas(i);
    Hh2 = (s/w0)^2*((s/w0)+1+alpha)/(((s/w0)+1)*((s/w0)^2 + alpha*(s/w0) + 1));
    Hl2 = ((1+alpha)*(s/w0)+1)/(((s/w0)+1)*((s/w0)^2 + alpha*(s/w0) + 1));
    set(gca,'ColorOrderIndex',i);
    plot(freqs_study, 180/pi*angle(squeeze(freqresp(Hh2, freqs_study, 'Hz'))), 'DisplayName', sprintf('$\\alpha = %g$', alpha));
    set(gca,'ColorOrderIndex',i);
    plot(freqs_study, 180/pi*angle(squeeze(freqresp(Hl2, freqs_study, 'Hz'))), 'HandleVisibility', 'off');
  end
  set(gca,'xscale','log');
  yticks(-180:90:180);
  ylim([-180 180]);
  xlabel('Relative Frequency $\frac{\omega}{\omega_0}$'); ylabel('Phase [deg]');
  legend('Location', 'northeast');
  hold off;
  linkaxes([ax1,ax2],'x');
  xlim([freqs_study(1), freqs_study(end)]);
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/comp_filters_param_alpha.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:comp_filters_param_alpha
#+CAPTION: Effect of the parameter $\alpha$ on the shape of the generated second order complementary filters ([[./figs/comp_filters_param_alpha.png][png]], [[./figs/comp_filters_param_alpha.pdf][pdf]])
[[file:figs/comp_filters_param_alpha.png]]

We now study the maximum norm of the filters function of the parameter $\alpha$. As we saw that the maximum norm of the filters is important for the robust merging of filters.
#+begin_src matlab :exports none
  alphas = logspace(-2, 2, 100);
  w0 = 2*pi*1;
  infnorms = zeros(size(alphas));

  for i = 1:length(alphas)
    alpha = alphas(i);
    Hh2 = (s/w0)^2*((s/w0)+1+alpha)/(((s/w0)+1)*((s/w0)^2 + alpha*(s/w0) + 1));
    Hl2 = ((1+alpha)*(s/w0)+1)/(((s/w0)+1)*((s/w0)^2 + alpha*(s/w0) + 1));
    infnorms(i) = norm(Hh2, 'inf');
  end
#+end_src

#+begin_src matlab
  figure;
  plot(alphas, infnorms)
  set(gca, 'xscale', 'log'); set(gca, 'yscale', 'log');
  xlabel('$\alpha$'); ylabel('$\|H_1\|_\infty$');
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/param_alpha_hinf_norm.pdf" :var figsize="wide-normal" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:param_alpha_hinf_norm
#+CAPTION: Evolution of the H-Infinity norm of the complementary filters with the parameter $\alpha$ ([[./figs/param_alpha_hinf_norm.png][png]], [[./figs/param_alpha_hinf_norm.pdf][pdf]])
[[file:figs/param_alpha_hinf_norm.png]]

** Third Order Complementary Filters
The following formula gives complementary filters with slopes of $-3$ and $3$:
\begin{align*}
  H_L(s) &= \frac{\left(1+(\alpha+1)(\beta+1)\right) (\frac{s}{\omega_0})^2 + (1+\alpha+\beta)(\frac{s}{\omega_0}) + 1}{\left(\frac{s}{\omega_0} + 1\right) \left( (\frac{s}{\omega_0})^2 + \alpha (\frac{s}{\omega_0}) + 1 \right) \left( (\frac{s}{\omega_0})^2 + \beta (\frac{s}{\omega_0}) + 1 \right)}\\
  H_H(s) &= \frac{(\frac{s}{\omega_0})^3 \left( (\frac{s}{\omega_0})^2 + (1+\alpha+\beta) (\frac{s}{\omega_0}) + (1+(\alpha+1)(\beta+1)) \right)}{\left(\frac{s}{\omega_0} + 1\right) \left( (\frac{s}{\omega_0})^2 + \alpha (\frac{s}{\omega_0}) + 1 \right) \left( (\frac{s}{\omega_0})^2 + \beta (\frac{s}{\omega_0}) + 1 \right)}
\end{align*}

The parameters are:
- $\omega_0$ is the blending frequency in rad/s
- $\alpha$ and $\beta$ that are used to change the shape of the filters similarly to the parameter $\alpha$ for the second order complementary filters

The filters are defined below and the result is shown on figure [[fig:complementary_filters_third_order]].

#+begin_src matlab
  alpha = 1;
  beta = 10;
  w0 = 2*pi*14;

  Hh3_ana = (s/w0)^3 * ((s/w0)^2 + (1+alpha+beta)*(s/w0) + (1+(alpha+1)*(beta+1)))/((s/w0 + 1)*((s/w0)^2+alpha*(s/w0)+1)*((s/w0)^2+beta*(s/w0)+1));
  Hl3_ana = ((1+(alpha+1)*(beta+1))*(s/w0)^2 + (1+alpha+beta)*(s/w0) + 1)/((s/w0 + 1)*((s/w0)^2+alpha*(s/w0)+1)*((s/w0)^2+beta*(s/w0)+1));
#+end_src

#+begin_src matlab :exports none
  figure;
  hold on;
  set(gca,'ColorOrderIndex',1)
  plot(freqs, abs(squeeze(freqresp(Hl3_ana, freqs, 'Hz'))), '-', 'DisplayName', '$H_L$ - Analytical');
  set(gca,'ColorOrderIndex',2)
  plot(freqs, abs(squeeze(freqresp(Hh3_ana, freqs, 'Hz'))), '-', 'DisplayName', '$H_H$ - Analytical');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('Magnitude');
  hold off;
  xlim([freqs(1), freqs(end)]);
  ylim([1e-3, 10]);
  xticks([0.1, 1, 10, 100, 1000]);
  legend('location', 'northeast');
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/complementary_filters_third_order.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:complementary_filters_third_order
#+CAPTION: Third order complementary filters using the analytical formula ([[./figs/complementary_filters_third_order.png][png]], [[./figs/complementary_filters_third_order.pdf][pdf]])
[[file:figs/complementary_filters_third_order.png]]

* H-Infinity synthesis of complementary filters
  :PROPERTIES:
  :header-args:matlab+: :tangle matlab/h_inf_synthesis_complementary_filters.m
  :header-args:matlab+: :comments org :mkdirp yes
  :END:
  <<sec:h_inf_synthesis_complementary_filters>>

** Introduction                                                      :ignore:
** ZIP file containing the data and matlab files                     :ignore:
#+begin_src bash :exports none :results none
  if [ matlab/h_inf_synthesis_complementary_filters.m -nt data/h_inf_synthesis_complementary_filters.zip ]; then
    cp matlab/h_inf_synthesis_complementary_filters.m h_inf_synthesis_complementary_filters.m;
    zip data/h_inf_synthesis_complementary_filters \
        h_inf_synthesis_complementary_filters.m
    rm h_inf_synthesis_complementary_filters.m;
  fi
#+end_src

#+begin_note
  All the files (data and Matlab scripts) are accessible [[file:data/h_inf_synthesis_complementary_filters.zip][here]].
#+end_note

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab
  freqs = logspace(-1, 3, 1000);
#+end_src

** Synthesis Architecture
We here synthesize the complementary filters using the $\mathcal{H}_\infty$ synthesis.
The goal is to specify upper bounds on the norms of $H_L$ and $H_H$ while ensuring their complementary property ($H_L + H_H = 1$).

In order to do so, we use the generalized plant shown on figure [[fig:sf_hinf_filters_plant_b]] where $w_L$ and $w_H$ weighting transfer functions that will be used to shape $H_L$ and $H_H$ respectively.

#+name: fig:sf_hinf_filters_plant_b
#+caption: Generalized plant used for the $\mathcal{H}_\infty$ synthesis of the complementary filters
[[file:figs/sf_hinf_filters_plant_b.png]]

The $\mathcal{H}_\infty$ synthesis applied on this generalized plant will give a transfer function $H_L$ (figure [[fig:sf_hinf_filters_b]]) such that the $\mathcal{H}_\infty$ norm of the transfer function from $w$ to $[z_H,\ z_L]$ is less than one:
\[ \left\| \begin{array}{c} H_L w_L \\ (1 - H_L) w_H \end{array} \right\|_\infty < 1 \]

Thus, if the above condition is verified, we can define $H_H = 1 - H_L$ and we have that:
\[ \left\| \begin{array}{c} H_L w_L \\ H_H w_H \end{array} \right\|_\infty < 1 \]
Which is almost (with an maximum error of $\sqrt{2}$) equivalent to:
\begin{align*}
  |H_L| &< \frac{1}{|w_L|}, \quad \forall \omega \\
  |H_H| &< \frac{1}{|w_H|}, \quad \forall \omega
\end{align*}

We then see that $w_L$ and $w_H$ can be used to shape both $H_L$ and $H_H$ while ensuring (by definition of $H_H = 1 - H_L$) their complementary property.

#+name: fig:sf_hinf_filters_b
#+caption: $\mathcal{H}_\infty$ synthesis of the complementary filters
[[file:figs/sf_hinf_filters_b.png]]

** Weights

#+begin_src matlab
  omegab = 2*pi*9;
  wH = (omegab)^2/(s + omegab*sqrt(1e-5))^2;
  omegab = 2*pi*28;
  wL = (s + omegab/(4.5)^(1/3))^3/(s*(1e-4)^(1/3) + omegab)^3;
#+end_src

#+begin_src matlab :exports none
  figure;
  hold on;
  set(gca,'ColorOrderIndex',1)
  plot(freqs, 1./abs(squeeze(freqresp(wL, freqs, 'Hz'))), '-', 'DisplayName', '$w_L$');
  set(gca,'ColorOrderIndex',2)
  plot(freqs, 1./abs(squeeze(freqresp(wH, freqs, 'Hz'))), '-', 'DisplayName', '$w_H$');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('Magnitude');
  hold off;
  xlim([freqs(1), freqs(end)]);
  ylim([1e-3, 10]);
  xticks([0.1, 1, 10, 100, 1000]);
  legend('location', 'northeast');
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/weights_wl_wh.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:weights_wl_wh
#+CAPTION: Weights on the complementary filters $w_L$ and $w_H$ and the associated performance weights ([[./figs/weights_wl_wh.png][png]], [[./figs/weights_wl_wh.pdf][pdf]])
[[file:figs/weights_wl_wh.png]]

** H-Infinity Synthesis
We define the generalized plant $P$ on matlab.
#+begin_src matlab
  P = [0   wL;
       wH -wH;
       1   0];
#+end_src

And we do the $\mathcal{H}_\infty$ synthesis using the =hinfsyn= command.
#+begin_src matlab :results output replace :exports both
  [Hl_hinf, ~, gamma, ~] = hinfsyn(P, 1, 1,'TOLGAM', 0.001, 'METHOD', 'ric', 'DISPLAY', 'on');
#+end_src

#+RESULTS:
#+begin_example
[Hl_hinf, ~, gamma, ~] = hinfsyn(P, 1, 1,'TOLGAM', 0.001, 'METHOD', 'ric', 'DISPLAY', 'on');
Test bounds:      0.0000 <  gamma  <=      1.7285

  gamma    hamx_eig  xinf_eig  hamy_eig   yinf_eig   nrho_xy   p/f
    1.729   4.1e+01   8.4e-12   1.8e-01    0.0e+00    0.0000    p
    0.864   3.9e+01 -5.8e-02#  1.8e-01    0.0e+00    0.0000    f
    1.296   4.0e+01   8.4e-12   1.8e-01    0.0e+00    0.0000    p
    1.080   4.0e+01   8.5e-12   1.8e-01    0.0e+00    0.0000    p
    0.972   3.9e+01 -4.2e-01#  1.8e-01    0.0e+00    0.0000    f
    1.026   4.0e+01   8.5e-12   1.8e-01    0.0e+00    0.0000    p
    0.999   3.9e+01   8.5e-12   1.8e-01    0.0e+00    0.0000    p
    0.986   3.9e+01 -1.2e+00#  1.8e-01    0.0e+00    0.0000    f
    0.993   3.9e+01 -8.2e+00#  1.8e-01    0.0e+00    0.0000    f
    0.996   3.9e+01   8.5e-12   1.8e-01    0.0e+00    0.0000    p
    0.994   3.9e+01   8.5e-12   1.8e-01    0.0e+00    0.0000    p
    0.993   3.9e+01 -3.2e+01#  1.8e-01    0.0e+00    0.0000    f

 Gamma value achieved:     0.9942
#+end_example

We then define the high pass filter $H_H = 1 - H_L$. The bode plot of both $H_L$ and $H_H$ is shown on figure [[fig:hinf_filters_results]].
#+begin_src matlab
  Hh_hinf = 1 - Hl_hinf;
#+end_src

** Obtained Complementary Filters

The obtained complementary filters are shown on figure [[fig:hinf_filters_results]].

#+begin_src matlab :exports none
  figure;
  hold on;
  set(gca,'ColorOrderIndex',1)
  plot(freqs, 1./abs(squeeze(freqresp(wL, freqs, 'Hz'))), '--', 'DisplayName', '$w_L$');
  set(gca,'ColorOrderIndex',2)
  plot(freqs, 1./abs(squeeze(freqresp(wH, freqs, 'Hz'))), '--', 'DisplayName', '$w_H$');

  set(gca,'ColorOrderIndex',1)
  plot(freqs, abs(squeeze(freqresp(Hl_hinf, freqs, 'Hz'))), '-', 'DisplayName', '$H_L$ - $\mathcal{H}_\infty$');
  set(gca,'ColorOrderIndex',2)
  plot(freqs, abs(squeeze(freqresp(Hh_hinf, freqs, 'Hz'))), '-', 'DisplayName', '$H_H$ - $\mathcal{H}_\infty$');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('Magnitude');
  hold off;
  xlim([freqs(1), freqs(end)]);
  ylim([1e-3, 10]);
  xticks([0.1, 1, 10, 100, 1000]);
  legend('location', 'northeast');
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/hinf_filters_results.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:hinf_filters_results
#+CAPTION: Obtained complementary filters using $\mathcal{H}_\infty$ synthesis ([[./figs/hinf_filters_results.png][png]], [[./figs/hinf_filters_results.pdf][pdf]])
[[file:figs/hinf_filters_results.png]]

* Feedback Control Architecture to generate Complementary Filters
  :PROPERTIES:
  :header-args:matlab+: :tangle matlab/feedback_generate_comp_filters.m
  :header-args:matlab+: :comments org :mkdirp yes
  :END:
  <<sec:feedback_generate_comp_filters>>

** Introduction                                                      :ignore:
The idea is here to use the fact that in a classical feedback architecture, $S + T = 1$, in order to design complementary filters.

Thus, all the tools that has been developed for classical feedback control can be used for complementary filter design.

** ZIP file containing the data and matlab files                     :ignore:
#+begin_src bash :exports none :results none
  if [ matlab/feedback_generate_comp_filters.m -nt data/feedback_generate_comp_filters.zip ]; then
    cp matlab/feedback_generate_comp_filters.m feedback_generate_comp_filters.m;
    zip data/feedback_generate_comp_filters \
        feedback_generate_comp_filters.m
    rm feedback_generate_comp_filters.m;
  fi
#+end_src

#+begin_note
  All the files (data and Matlab scripts) are accessible [[file:data/feedback_generate_comp_filters.zip][here]].
#+end_note

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab
  freqs = logspace(-2, 2, 1000);
#+end_src

** Architecture
#+name: fig:complementary_filters_feedback_architecture
#+caption: Architecture used to generate the complementary filters
[[file:figs/complementary_filters_feedback_architecture.png]]

We have:
\[ y = \underbrace{\frac{L}{L + 1}}_{H_L} y_1 + \underbrace{\frac{1}{L + 1}}_{H_H} y_2 \]
with $H_L + H_H = 1$.

The only thing to design is $L$ such that the complementary filters are stable with the wanted shape.

A simple choice is:
\[ L = \left(\frac{\omega_c}{s}\right)^2 \frac{\frac{s}{\omega_c / \alpha} + 1}{\frac{s}{\omega_c} + \alpha} \]

Which contains two integrator and a lead. $\omega_c$ is used to tune the crossover frequency and $\alpha$ the trade-off "bump" around blending frequency and filtering away from blending frequency.

** Loop Gain Design
Let's first define the loop gain $L$.
#+begin_src matlab
  wc = 2*pi*1;
  alpha = 2;

  L = (wc/s)^2 * (s/(wc/alpha) + 1)/(s/wc + alpha);
#+end_src

#+begin_src matlab :exports none
  figure;

  ax1 = subplot(2,1,1);
  plot(freqs, abs(squeeze(freqresp(L, freqs, 'Hz'))), '-');
  ylabel('Magnitude');
  set(gca, 'XScale', 'log');
  set(gca, 'YScale', 'log');

  ax2 = subplot(2,1,2);
  plot(freqs, 180/pi*phase(squeeze(freqresp(L, freqs, 'Hz'))), '--');
  xlabel('Frequency [Hz]'); ylabel('Phase [deg]');
  set(gca, 'XScale', 'log');
  ylim([-180, 0]);
  yticks([-360:90:360]);

  linkaxes([ax1,ax2],'x');
  xlim([freqs(1), freqs(end)]);
  xticks([0.1, 1, 10, 100, 1000]);
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/loop_gain_bode_plot.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:loop_gain_bode_plot
#+CAPTION: Bode plot of the loop gain $L$ ([[./figs/loop_gain_bode_plot.png][png]], [[./figs/loop_gain_bode_plot.pdf][pdf]])
[[file:figs/loop_gain_bode_plot.png]]

** Complementary Filters Obtained
We then compute the resulting low pass and high pass filters.
#+begin_src matlab
  Hl = L/(L + 1);
  Hh = 1/(L + 1);
#+end_src

#+begin_src matlab :exports none
  alphas = [1, 2, 10];

  figure;
  hold on;
  for i = 1:length(alphas)
    alpha = alphas(i);
    L = (wc/s)^2 * (s/(wc/alpha) + 1)/(s/wc + alpha);
    Hl = L/(L + 1);
    Hh = 1/(L + 1);
    set(gca,'ColorOrderIndex',i)
    plot(freqs, abs(squeeze(freqresp(Hl, freqs, 'Hz'))), 'DisplayName', sprintf('$\\alpha = %.0f$', alpha));
    set(gca,'ColorOrderIndex',i)
    plot(freqs, abs(squeeze(freqresp(Hh, freqs, 'Hz'))), 'HandleVisibility', 'off');
  end
  set(gca, 'xscale', 'log'); set(gca, 'yscale', 'log');
  xlabel('Frequency [Hz]'); ylabel('Amplitude')
  legend('location', 'northeast');
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/low_pass_high_pass_filters.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:low_pass_high_pass_filters
#+CAPTION: Low pass and High pass filters $H_L$ and $H_H$ for different values of $\alpha$ ([[./figs/low_pass_high_pass_filters.png][png]], [[./figs/low_pass_high_pass_filters.pdf][pdf]])
[[file:figs/low_pass_high_pass_filters.png]]

* Generating 3 complementary filters
  :PROPERTIES:
  :header-args:matlab+: :tangle matlab/three_comp_filters.m
  :header-args:matlab+: :comments org :mkdirp yes
  :END:
  <<sec:three_comp_filters>>

** Introduction                                                      :ignore:
** ZIP file containing the data and matlab files                     :ignore:
#+begin_src bash :exports none :results none
  if [ matlab/three_comp_filters.m -nt data/three_comp_filters.zip ]; then
    cp matlab/three_comp_filters.m three_comp_filters.m;
    zip data/three_comp_filters \
        three_comp_filters.m
    rm three_comp_filters.m;
  fi
#+end_src

#+begin_note
  All the files (data and Matlab scripts) are accessible [[file:data/three_comp_filters.zip][here]].
#+end_note

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab
  freqs = logspace(-2, 4, 1000);
#+end_src

** Theory
We want:
\begin{align*}
  & |H_1 w_1| < 1, \quad \forall\omega\\
  & |H_2 w_2| < 1, \quad \forall\omega\\
  & |H_3 w_3| < 1, \quad \forall\omega\\
  & H_1 + H_2 + H_3 = 1
\end{align*}

For that, we use the $\mathcal{H}_\infty$ synthesis with the architecture shown on figure [[fig:comp_filter_three_hinf]].

#+name: fig:comp_filter_three_hinf
#+caption: Generalized architecture for generating 3 complementary filters
[[file:figs/comp_filter_three_hinf.png]]

The $\mathcal{H}_\infty$ objective is:
\begin{align*}
  & |H_1 w_1| < 1, \quad \forall\omega\\
  & |H_2 w_2| < 1, \quad \forall\omega\\
  & |(1 - H_1 - H_2) w_3| < 1, \quad \forall\omega\\
\end{align*}

And thus if we choose $H_3 = 1 - H_1 - H_2$ we have solved the problem.

** Weights
First we define the weights.
#+begin_src matlab
  w1 = 0.35*(1 + s/2/pi/1)^2/(1 + s/2/pi/100)^2;
  w2 = 0.35*(1 + s/2/pi/1)^2/(sqrt(1e-4) + s/2/pi/1)^2*(1 + s/2/pi/100)^2/(1 + s/2/pi/10000)^2;
  w3 = 0.35*(1 + s/2/pi/100)^2/(sqrt(1e-4) + s/2/pi/100)^2;
#+end_src

#+begin_src matlab :exports none
  figure;
  hold on;
  set(gca,'ColorOrderIndex',1)
  plot(freqs, 1./abs(squeeze(freqresp(w1, freqs, 'Hz'))), '--', 'DisplayName', '$w_1$');
  set(gca,'ColorOrderIndex',2)
  plot(freqs, 1./abs(squeeze(freqresp(w2, freqs, 'Hz'))), '--', 'DisplayName', '$w_2$');
  set(gca,'ColorOrderIndex',3)
  plot(freqs, 1./abs(squeeze(freqresp(w3, freqs, 'Hz'))), '--', 'DisplayName', '$w_3$');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('Magnitude');
  hold off;
  xlim([freqs(1), freqs(end)]);
  xticks([0.01, 0.1, 1, 10, 100, 1000]);
  legend('location', 'northeast');
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/three_weighting_functions.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:three_weighting_functions
#+CAPTION: Three weighting functions used for the $\mathcal{H}_\infty$ synthesis of the complementary filters ([[./figs/three_weighting_functions.png][png]], [[./figs/three_weighting_functions.pdf][pdf]])
[[file:figs/three_weighting_functions.png]]

** H-Infinity Synthesis
Then we create the generalized plant =P=.
#+begin_src matlab
  P = [w3 -w3 -w3;
       0   w2  0 ;
       0   0   w1;
       1   0   0];
#+end_src

And we do the $\mathcal{H}_\infty$ synthesis.
#+begin_src matlab :results output replace :exports both
  [H, ~, gamma, ~] = hinfsyn(P, 1, 2,'TOLGAM', 0.001, 'METHOD', 'ric', 'DISPLAY', 'on');
#+end_src

#+RESULTS:
#+begin_example
[H, ~, gamma, ~] = hinfsyn(P, 1, 2,'TOLGAM', 0.001, 'METHOD', 'ric', 'DISPLAY', 'on');
Resetting value of Gamma min based on D_11, D_12, D_21 terms

Test bounds:      0.3500 <  gamma  <=      2.5115

  gamma    hamx_eig  xinf_eig  hamy_eig   yinf_eig   nrho_xy   p/f
    2.512   4.4e+00   2.7e-15   6.3e-02   -8.0e-09    0.0000    p
    1.431   4.3e+00 -7.5e-11   6.3e-02    0.0e+00    0.0000    p
    0.890   4.0e+00 -2.4e+01#  6.3e-02    0.0e+00    0.0000    f
    1.161   4.2e+00 -1.7e-13   6.3e-02   -8.1e-09    0.0000    p
    1.025   4.1e+00 -2.0e-01#  6.3e-02   -8.1e-09    0.0000    f
    1.093   4.2e+00 -2.0e+01#  6.3e-02    0.0e+00    0.0000    f
    1.127   4.2e+00 -1.4e+02#  6.3e-02    0.0e+00    0.0000    f
    1.144   4.2e+00 -2.2e+04#  6.3e-02   -1.9e-10    0.0000    f
    1.152   4.2e+00   3.5e-15   6.3e-02    0.0e+00    0.0000    p
    1.148   4.2e+00   8.7e-15   6.3e-02   -1.9e-10    0.0000    p
    1.146   4.2e+00   5.0e-15   6.3e-02    0.0e+00    0.0000    p
    1.145   4.2e+00   5.5e-15   6.3e-02    0.0e+00    0.0000    p
    1.144   4.2e+00   5.5e-16   6.3e-02   -8.0e-09    0.0000    p

 Gamma value achieved:     1.1442
#+end_example

** Obtained Complementary Filters
The obtained filters are:
#+begin_src matlab
  H1 = tf(H(2));
  H2 = tf(H(1));
  H3 = 1 - H1 - H2;
#+end_src

#+begin_src matlab :exports none
  figure;
  hold on;
  set(gca,'ColorOrderIndex',1)
  plot(freqs, 1./abs(squeeze(freqresp(w1, freqs, 'Hz'))), '--', 'DisplayName', '$w_1$');
  set(gca,'ColorOrderIndex',2)
  plot(freqs, 1./abs(squeeze(freqresp(w2, freqs, 'Hz'))), '--', 'DisplayName', '$w_2$');
  set(gca,'ColorOrderIndex',3)
  plot(freqs, 1./abs(squeeze(freqresp(w3, freqs, 'Hz'))), '--', 'DisplayName', '$w_3$');
  set(gca,'ColorOrderIndex',1)
  plot(freqs, abs(squeeze(freqresp(H1, freqs, 'Hz'))), '-', 'DisplayName', '$H_1$');
  set(gca,'ColorOrderIndex',2)
  plot(freqs, abs(squeeze(freqresp(H2, freqs, 'Hz'))), '-', 'DisplayName', '$H_2$');
  set(gca,'ColorOrderIndex',3)
  plot(freqs, abs(squeeze(freqresp(H3, freqs, 'Hz'))), '-', 'DisplayName', '$H_3$');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('Magnitude');
  hold off;
  xlim([freqs(1), freqs(end)]);
  xticks([0.01, 0.1, 1, 10, 100, 1000]);
  legend('location', 'northeast');
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/three_complementary_filters_results.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:three_complementary_filters_results
#+CAPTION: The three complementary filters obtained after $\mathcal{H}_\infty$ synthesis ([[./figs/three_complementary_filters_results.png][png]], [[./figs/three_complementary_filters_results.pdf][pdf]])
[[file:figs/three_complementary_filters_results.png]]

* Try to implement complementary filters for LIGO
  :PROPERTIES:
  :header-args:matlab+: :tangle matlab/comp_filters_ligo.m
  :header-args:matlab+: :comments org :mkdirp yes
  :END:
  <<sec:comp_filters_ligo>>

** Introduction                                                      :ignore:
Let's try to design complementary filters that are corresponding to the complementary filters design for the LIGO and described in cite:hua05_low_ligo.

The FIR complementary filters designed in cite:hua05_low_ligo are of order 512 and their bode plot is shown on figure [[fig:fir_ligo_comp_filters]].

#+name: fig:fir_ligo_comp_filters
#+caption: Obtained complementary FIR filters
[[file:figs/fir_ligo_comp_filters.png]]

** ZIP file containing the data and matlab files                     :ignore:
#+begin_src bash :exports none :results none
  if [ matlab/comp_filters_ligo.m -nt data/comp_filters_ligo.zip ]; then
    cp matlab/comp_filters_ligo.m comp_filters_ligo.m;
    zip data/comp_filters_ligo \
        comp_filters_ligo.m
    rm comp_filters_ligo.m;
  fi
#+end_src

#+begin_note
  All the files (data and Matlab scripts) are accessible [[file:data/comp_filters_ligo.zip][here]].
#+end_note

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

#+begin_src matlab
  freqs = logspace(-3, 0, 1000);
#+end_src

** Specifications
The specifications for the filters are:
1. From $0$ to $0.008\text{ Hz}$,the magnitude of the filters transfer function should be less than or equal to $8 \times 10^{-3}$
2. From $0.008\text{ Hz}$ to $0.04\text{ Hz}$, it attenuates the input signal proportional to frequency cubed
3. Between $0.04\text{ Hz}$ and $0.1\text{ Hz}$, the magnitude of the transfer function should be less than 3
4. Above $0.1\text{ Hz}$, the maximum of the magnitude of the complement filter should be as close to zero as possible. In our system, we would like to have the magnitude of the complementary filter to be less than $0.1$. As the filters obtained in cite:hua05_low_ligo have a magnitude of $0.045$, we will set that as our requirement

The specifications are translated in upper bounds of the complementary filters are shown on figure [[fig:ligo_specifications]].

#+begin_src matlab :exports none
  figure;
  hold on;
  set(gca,'ColorOrderIndex',1)
  plot([0.0001, 0.008], [8e-3, 8e-3], ':', 'DisplayName', 'Spec. on $H_H$');
  set(gca,'ColorOrderIndex',1)
  plot([0.008 0.04], [8e-3, 1], ':', 'HandleVisibility', 'off');
  set(gca,'ColorOrderIndex',1)
  plot([0.04 0.1], [3, 3], ':', 'HandleVisibility', 'off');
  set(gca,'ColorOrderIndex',2)
  plot([0.1, 10], [0.1, 0.1], ':', 'DisplayName', 'Spec. on $H_L$');
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('Magnitude');
  hold off;
  xlim([freqs(1), freqs(end)]);
  ylim([1e-4, 10]);
  legend('location', 'northeast');
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/ligo_specifications.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:ligo_specifications
#+CAPTION: Specification for the LIGO complementary filters ([[./figs/ligo_specificationss.png][png]], [[./figs/ligo_specificationss.pdf][pdf]])
[[file:figs/ligo_specifications.png]]

** FIR Filter
We here try to implement the FIR complementary filter synthesis as explained in cite:hua05_low_ligo.
For that, we use the [[http://cvxr.com/cvx/][CVX matlab Toolbox]].

We setup the CVX toolbox and use the =SeDuMi= solver.
#+begin_src matlab
  cvx_startup;
  cvx_solver sedumi;
#+end_src

We define the frequency vectors on which we will constrain the norm of the FIR filter.
#+begin_src matlab
  w1 = 0:4.06e-4:0.008;
  w2 = 0.008:4.06e-4:0.04;
  w3 = 0.04:8.12e-4:0.1;
  w4 = 0.1:8.12e-4:0.83;
#+end_src

We then define the order of the FIR filter.
#+begin_src matlab
  n = 512;
#+end_src

#+begin_src matlab
  A1 = [ones(length(w1),1),  cos(kron(w1'.*(2*pi),[1:n-1]))];
  A2 = [ones(length(w2),1),  cos(kron(w2'.*(2*pi),[1:n-1]))];
  A3 = [ones(length(w3),1),  cos(kron(w3'.*(2*pi),[1:n-1]))];
  A4 = [ones(length(w4),1),  cos(kron(w4'.*(2*pi),[1:n-1]))];

  B1 = [zeros(length(w1),1), sin(kron(w1'.*(2*pi),[1:n-1]))];
  B2 = [zeros(length(w2),1), sin(kron(w2'.*(2*pi),[1:n-1]))];
  B3 = [zeros(length(w3),1), sin(kron(w3'.*(2*pi),[1:n-1]))];
  B4 = [zeros(length(w4),1), sin(kron(w4'.*(2*pi),[1:n-1]))];
#+end_src

We run the convex optimization.
#+begin_src matlab :results output replace :wrap example
  cvx_begin

  variable y(n+1,1)

  % t
  maximize(-y(1))

  for i = 1:length(w1)
      norm([0 A1(i,:); 0 B1(i,:)]*y) <= 8e-3;
  end

  for  i = 1:length(w2)
      norm([0 A2(i,:); 0 B2(i,:)]*y) <= 8e-3*(2*pi*w2(i)/(0.008*2*pi))^3;
  end

  for i = 1:length(w3)
      norm([0 A3(i,:); 0 B3(i,:)]*y) <= 3;
  end

  for i = 1:length(w4)
      norm([[1 0]'- [0 A4(i,:); 0 B4(i,:)]*y]) <= y(1);
  end

  cvx_end

  h = y(2:end);
#+end_src

#+RESULTS:
#+begin_example
cvx_begin
[Warning: A non-empty cvx problem already exists in this scope.
   It is being overwritten.]
[> In cvxprob (line 28)
  In cvx_begin (line 41)]
variable y(n+1,1)
% t
maximize(-y(1))
for i = 1:length(w1)
    norm([0 A1(i,:); 0 B1(i,:)]*y) <= 8e-3;
end
for  i = 1:length(w2)
    norm([0 A2(i,:); 0 B2(i,:)]*y) <= 8e-3*(2*pi*w2(i)/(0.008*2*pi))^3;
end
for i = 1:length(w3)
    norm([0 A3(i,:); 0 B3(i,:)]*y) <= 3;
end
for i = 1:length(w4)
    norm([[1 0]'- [0 A4(i,:); 0 B4(i,:)]*y]) <= y(1);
end
cvx_end

Calling SeDuMi 1.34: 4291 variables, 1586 equality constraints
   For improved efficiency, SeDuMi is solving the dual problem.
------------------------------------------------------------
SeDuMi 1.34 (beta) by AdvOL, 2005-2008 and Jos F. Sturm, 1998-2003.
Alg = 2: xz-corrector, Adaptive Step-Differentiation, theta = 0.250, beta = 0.500
eqs m = 1586, order n = 3220, dim = 4292, blocks = 1073
nnz(A) = 1100727 + 0, nnz(ADA) = 1364794, nnz(L) = 683190
 it :     b*y       gap    delta  rate   t/tP*  t/tD*   feas cg cg  prec
  0 :            4.11E+02 0.000
  1 :  -2.58E+00 1.25E+02 0.000 0.3049 0.9000 0.9000   4.87  1  1  3.0E+02
  2 :  -2.36E+00 3.90E+01 0.000 0.3118 0.9000 0.9000   1.83  1  1  6.6E+01
  3 :  -1.69E+00 1.31E+01 0.000 0.3354 0.9000 0.9000   1.76  1  1  1.5E+01
  4 :  -8.60E-01 7.10E+00 0.000 0.5424 0.9000 0.9000   2.48  1  1  4.8E+00
  5 :  -4.91E-01 5.44E+00 0.000 0.7661 0.9000 0.9000   3.12  1  1  2.5E+00
  6 :  -2.96E-01 3.88E+00 0.000 0.7140 0.9000 0.9000   2.62  1  1  1.4E+00
  7 :  -1.98E-01 2.82E+00 0.000 0.7271 0.9000 0.9000   2.14  1  1  8.5E-01
  8 :  -1.39E-01 2.00E+00 0.000 0.7092 0.9000 0.9000   1.78  1  1  5.4E-01
  9 :  -9.99E-02 1.30E+00 0.000 0.6494 0.9000 0.9000   1.51  1  1  3.3E-01
 10 :  -7.57E-02 8.03E-01 0.000 0.6175 0.9000 0.9000   1.31  1  1  2.0E-01
 11 :  -5.99E-02 4.22E-01 0.000 0.5257 0.9000 0.9000   1.17  1  1  1.0E-01
 12 :  -5.28E-02 2.45E-01 0.000 0.5808 0.9000 0.9000   1.08  1  1  5.9E-02
 13 :  -4.82E-02 1.28E-01 0.000 0.5218 0.9000 0.9000   1.05  1  1  3.1E-02
 14 :  -4.56E-02 5.65E-02 0.000 0.4417 0.9045 0.9000   1.02  1  1  1.4E-02
 15 :  -4.43E-02 2.41E-02 0.000 0.4265 0.9004 0.9000   1.01  1  1  6.0E-03
 16 :  -4.37E-02 8.90E-03 0.000 0.3690 0.9070 0.9000   1.00  1  1  2.3E-03
 17 :  -4.35E-02 3.24E-03 0.000 0.3641 0.9164 0.9000   1.00  1  1  9.5E-04
 18 :  -4.34E-02 1.55E-03 0.000 0.4788 0.9086 0.9000   1.00  1  1  4.7E-04
 19 :  -4.34E-02 8.77E-04 0.000 0.5653 0.9169 0.9000   1.00  1  1  2.8E-04
 20 :  -4.34E-02 5.05E-04 0.000 0.5754 0.9034 0.9000   1.00  1  1  1.6E-04
 21 :  -4.34E-02 2.94E-04 0.000 0.5829 0.9136 0.9000   1.00  1  1  9.9E-05
 22 :  -4.34E-02 1.63E-04 0.015 0.5548 0.9000 0.0000   1.00  1  1  6.6E-05
 23 :  -4.33E-02 9.42E-05 0.000 0.5774 0.9053 0.9000   1.00  1  1  3.9E-05
 24 :  -4.33E-02 6.27E-05 0.000 0.6658 0.9148 0.9000   1.00  1  1  2.6E-05
 25 :  -4.33E-02 3.75E-05 0.000 0.5972 0.9187 0.9000   1.00  1  1  1.6E-05
 26 :  -4.33E-02 1.89E-05 0.000 0.5041 0.9117 0.9000   1.00  1  1  8.6E-06
 27 :  -4.33E-02 9.72E-06 0.000 0.5149 0.9050 0.9000   1.00  1  1  4.5E-06
 28 :  -4.33E-02 2.94E-06 0.000 0.3021 0.9194 0.9000   1.00  1  1  1.5E-06
 29 :  -4.33E-02 9.73E-07 0.000 0.3312 0.9189 0.9000   1.00  2  2  5.3E-07
 30 :  -4.33E-02 2.82E-07 0.000 0.2895 0.9063 0.9000   1.00  2  2  1.6E-07
 31 :  -4.33E-02 8.05E-08 0.000 0.2859 0.9049 0.9000   1.00  2  2  4.7E-08
 32 :  -4.33E-02 1.43E-08 0.000 0.1772 0.9059 0.9000   1.00  2  2  8.8E-09

iter seconds digits       c*x               b*y
 32     46.6   6.8 -4.3334083581e-02 -4.3334090214e-02
|Ax-b| =   3.7e-09, [Ay-c]_+ =   1.1E-10, |x|=  1.0e+00, |y|=  2.6e+00

Detailed timing (sec)
   Pre          IPM          Post
3.281E+00    4.295E+01    1.497E-02
Max-norms: ||b||=1, ||c|| = 3,
Cholesky |add|=0, |skip| = 0, ||L.L|| = 4.26267.
------------------------------------------------------------
Status: Solved
Optimal value (cvx_optval): -0.0433341
h = y(2:end);
#+end_example

Finally, we compute the filter response over the frequency vector defined and the result is shown on figure [[fig:fir_filter_ligo]] which is very close to the filters obtain in cite:hua05_low_ligo and shown on figure [[fig:fir_ligo_comp_filters]].

#+begin_src matlab
  w = [w1 w2 w3 w4];
  H = [exp(-j*kron(w'.*2*pi,[0:n-1]))]*h;
#+end_src

#+begin_src matlab :exports none
  figure;

  ax1 = subplot(2,1,1);
  hold on;
  plot(w, abs(H), 'k-');
  plot(w, abs(1-H), 'k--');
  hold off;
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  ylabel('Magnitude');
  set(gca, 'XTickLabel',[]);
  ylim([5e-3, 5]);

  ax2 = subplot(2,1,2);
  hold on;
  plot(w,unwrap(angle(H)).*180/pi, 'k-');
  plot(w,unwrap(angle(1-H))*180/pi, 'k--');
  hold off;
  xlabel('Frequency [Hz]'); ylabel('Phase [deg]');
  set(gca, 'XScale', 'log');
  yticks([-540:90:360]);

  linkaxes([ax1,ax2],'x');
  xlim([1e-3, 1]);
  xticks([0.01, 0.1, 1, 10, 100, 1000]);
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/fir_filter_ligo.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:fir_filter_ligo
#+CAPTION: FIR Complementary filters obtain after convex optimization ([[./figs/fir_filter_ligo.png][png]], [[./figs/fir_filter_ligo.pdf][pdf]])
[[file:figs/fir_filter_ligo.png]]

** Weights
We design weights that will be used for the $\mathcal{H}_\infty$ synthesis of the complementary filters.
These weights will determine the order of the obtained filters.
Here are the requirements on the filters:
- reasonable order
- to be as close as possible to the specified upper bounds
- stable minimum phase

The weights are shown below and their bode plot is shown on figure [[]]

#+begin_src matlab :exports none
  w1 = 2*pi*0.008; x1 = 0.35;
  w2 = 2*pi*0.04;  x2 = 0.5;
  w3 = 2*pi*0.05;  x3 = 0.5;

  % Slope of +3 from w1
  wH = 0.008*(s^2/w1^2 + 2*x1/w1*s + 1)*(s/w1 + 1);
  % Little bump from w2 to w3
  wH = wH*(s^2/w2^2 + 2*x2/w2*s + 1)/(s^2/w3^2 + 2*x3/w3*s + 1);
  % No Slope at high frequencies
  wH = wH/(s^2/w3^2 + 2*x3/w3*s + 1)/(s/w3 + 1);
  % Little bump between w2 and w3
  w0 = 2*pi*0.045; xi = 0.1; A = 2; n = 1;
  wH = wH*((s^2 + 2*w0*xi*A^(1/n)*s + w0^2)/(s^2 + 2*w0*xi*s + w0^2))^n;

  wH = 1/wH;
#+end_src

#+begin_src matlab :exports results :results output replace :wrap example
  wH
#+end_src

#+RESULTS:
#+begin_example
wH

wH =

           0.32768 (s+0.3142) (s^2 + 0.3142s + 0.0987)^2 (s^2 + 0.05655s + 0.07994)
  -------------------------------------------------------------------------------------------
  (s+0.05027) (s^2 + 0.03519s + 0.002527) (s^2 + 0.2513s + 0.06317) (s^2 + 0.1131s + 0.07994)

Continuous-time zero/pole/gain model.
#+end_example


#+begin_src matlab :exports none
  w1 = 2*pi*0.090; x1 = 0.69; n = 10;
  wL = (0.045*(s^2 + 2*x1*w1*s + w1^2)^n)/s^(2*n);

  wL = 1/wL;
#+end_src

#+begin_src matlab :exports results :results output replace :wrap example
  wL
#+end_src

#+RESULTS:
#+begin_example
wL

wL =

          22.222 s^20
  ---------------------------
  (s^2 + 0.7804s + 0.3198)^10

Continuous-time zero/pole/gain model.
#+end_example

#+begin_src matlab :exports none
  figure;
  hold on;
  set(gca,'ColorOrderIndex',1)
  plot([0.0001, 0.008], [8e-3, 8e-3], ':', 'DisplayName', 'Spec. on $H_H$');
  set(gca,'ColorOrderIndex',1)
  plot([0.008 0.04], [8e-3, 1], ':', 'HandleVisibility', 'off');
  set(gca,'ColorOrderIndex',1)
  plot([0.04 0.1], [3, 3], ':', 'HandleVisibility', 'off');

  set(gca,'ColorOrderIndex',2)
  plot([0.1, 10], [0.045, 0.045], ':', 'DisplayName', 'Spec. on $H_L$');

  set(gca,'ColorOrderIndex',1)
  plot(freqs, abs(squeeze(freqresp(inv(wH), freqs, 'Hz'))), '--', 'DisplayName', '$|w_H|^{-1}$');
  set(gca,'ColorOrderIndex',2)
  plot(freqs, abs(squeeze(freqresp(inv(wL), freqs, 'Hz'))), '--', 'DisplayName', '$|w_L|^{-1}$');

  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('Magnitude');
  hold off;
  xlim([freqs(1), freqs(end)]);
  ylim([1e-3, 10]);
  legend('location', 'southeast');
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/ligo_weights.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:ligo_weights
#+CAPTION: Weights for the $\mathcal{H}_\infty$ synthesis ([[./figs/ligo_weights.png][png]], [[./figs/ligo_weights.pdf][pdf]])
[[file:figs/ligo_weights.png]]

*** Old Weights                                                  :noexport:
#+begin_src matlab
  % wH = 130*(((s/2/pi/0.06)+1)^3)/((s/2/pi/0.008)+1)^3;
  % wL = 10000*(((s/2/pi/0.6))^3)/((s/2/pi/0.06)+1)^3;
  wH = 0.29*(s+0.4262)*(s^2 + 0.2664*s + 0.1455)/((s+0.04299)*(s^2 + 0.04249*s + 0.003472));
  wH = (s+0.382)*(s^2 + 0.5227*s + 0.1127)*(s^2 + 0.1442*s + 0.1068)/(4.1123*(s+0.03679)*(s^2 + 0.03609*s + 0.003761)*(s^2 + 0.2645*s + 0.06304));
  wH =(s+0.382)*(s^2 + 0.3947*s + 0.1045)*(s^2 + 0.0964*s + 0.1034)/(4.1649*(s+0.04441)*(s^2 + 0.02625*s + 0.002472)*(s^2 + 0.1067*s + 0.07173));
  wH = (s+0.4177)*(s^2 + 0.3598*s + 0.09343)*(s^2 + 0.0964*s + 0.1034)/(3.6058*(s+0.04669)*(s^2 + 0.04128*s + 0.002617)*(s^2 + 0.1469*s + 0.07533));
  wH = (s+0.3278)*(s^2 + 0.4229*s + 0.1041)*(s^2 + 0.0964*s + 0.1034)/(3.1517*(s+0.04669)*(s^2 + 0.04128*s + 0.002617)*(s^2 + 0.1469*s + 0.07533));

  wL = 10*s^3/((s+0.6564)*(s^2 + 0.4507*s + 0.3412));
  % wL = 361.5*s^3/((s+2.061)*(s^2 + 1.918*s + 4.398));
  wL = 10*s^3/((s+0.6564)*(s^2 + 0.4507*s + 0.3412));
  wL = 8.7119*s^4/((s^2 + 0.1311*s + 0.4168)*(s^2 + 1.285*s + 1.711));
  wL = 10*s^4/((s^2 + 0.3097*s + 0.5118)*(s^2 + 0.5226*s + 0.8615));
  wL = s^4/(0.10179*(s^2 + 1.529*s + 0.807)*(s^2 + 0.2834*s + 0.4085));
  wL = s^6/(0.098821*(s^2 + 0.5532*s + 0.2624)*(s^2 + 1.529*s + 0.807)*(s^2 + 0.2834*s + 0.4085));
  wL = s^8/(0.097585*(s^2 + 0.9708*s + 0.3387)*(s^2 + 1.423*s + 0.7164)*(s^2 + 0.5047*s + 0.3387)*(s^2 + 0.2574*s + 0.3816));
#+end_src

#+begin_src matlab
  w1 = 2*pi*0.0075; x1 = 0.35;
  w2 = 2*pi*0.04;  x2 = 0.5;
  w3 = 2*pi*0.05;  x3 = 0.5;
  wH = 0.008*(s^2/w1^2 + 2*x1/w1*s + 1)*(s/w1 + 1);
  % wH = wH*(s^2/w2^2 + 2*x2/w2*s + 1)/(s^2/w3^2 + 2*x3/w3*s + 1);
  wH = wH/(s^2/w3^2 + 2*x3/w3*s + 1)/(s/w3 + 1);

  w1 = 2*pi*0.09; x1 = 0.6; n = 10;
  wL = (0.1*(s^2 + 2*x1*w1*s + w1^2)^n)/s^(2*n);
  w1 = 2*pi*0.09; x1 = 0.65; n = 10;
  wL = (0.045*(s^2 + 2*x1*w1*s + w1^2)^n)/s^(2*n);

  w2 = 2*pi*0.042; x2 = 0.16;
  w3 = 2*pi*0.043; x3 = 0.16;
  n = 4;
  wll = (s^2/w2^2 + 2*x2/w2*s + 1)^n/(s^2/w3^2 + 2*x3/w3*s + 1)^n;
  % w0 = 2*pi*0.04; A = 2; n = 8;
  % wll = ((s^2 + 2*w0*A^(1/n)*s + w0^2)/(s^2 + 2*w0*s + w0^2))^n;

  wH = wH*wll;

  wH = 1/wH;
  wL = 1/wL;
#+end_src

Alternative:
#+begin_src matlab
  w1 = 2*pi*0.008; x1 = 0.35;
  w2 = 2*pi*0.04;  x2 = 0.5;
  w3 = 2*pi*0.05;  x3 = 0.5;
  wH = 0.008*(s^2/w1^2 + 2*x1/w1*s + 1)*(s/w1 + 1);
  wH = wH*(s^2/w2^2 + 2*x2/w2*s + 1)/(s^2/w3^2 + 2*x3/w3*s + 1);
  wH = wH/(s^2/w3^2 + 2*x3/w3*s + 1)/(s/w3 + 1);

  w1 = 2*pi*0.09; x1 = 0.6; n = 10;
  wL = (0.1*(s^2 + 2*x1*w1*s + w1^2)^n)/s^(2*n);
  w1 = 2*pi*0.09; x1 = 0.65; n = 10;
  wL = (0.045*(s^2 + 2*x1*w1*s + w1^2)^n)/s^(2*n);

  % w2 = 2*pi*0.042; x2 = 0.16;
  % w3 = 2*pi*0.043; x3 = 0.16;
  % n = 4;
  % wll = (s^2/w2^2 + 2*x2/w2*s + 1)^n/(s^2/w3^2 + 2*x3/w3*s + 1)^n;
  % w0 = 2*pi*0.04; A = 2; n = 8;
  % wll = ((s^2 + 2*w0*A^(1/n)*s + w0^2)/(s^2 + 2*w0*s + w0^2))^n;

  % wH = wH*wll;

  wH = 1/wH;
  wL = 1/wL;
#+end_src


** H-Infinity Synthesis
We define the generalized plant as shown on figure [[fig:sf_hinf_filters_plant_b]].
#+begin_src matlab
  P = [0   wL;
       wH -wH;
       1   0];
#+end_src

And we do the $\mathcal{H}_\infty$ synthesis using the =hinfsyn= command.
#+begin_src matlab :results output replace :exports both :wrap example
  [Hl, ~, gamma, ~] = hinfsyn(P, 1, 1,'TOLGAM', 0.001, 'METHOD', 'ric', 'DISPLAY', 'on');
#+end_src

#+RESULTS:
#+begin_example
[Hl, ~, gamma, ~] = hinfsyn(P, 1, 1,'TOLGAM', 0.001, 'METHOD', 'ric', 'DISPLAY', 'on');
Resetting value of Gamma min based on D_11, D_12, D_21 terms

Test bounds:      0.3276 <  gamma  <=      1.6807

  gamma    hamx_eig  xinf_eig  hamy_eig   yinf_eig   nrho_xy   p/f
    1.681   2.8e-02 -4.6e-19   1.8e-02   -2.8e-18    0.0000    p
    1.004   2.8e-02 -1.4e-18   1.8e-02   -6.6e-12    0.0000    p
    0.666   2.8e-02 -3.0e-01#  1.8e-02   -1.7e-11    0.0000    f
    0.835   2.8e-02 -1.3e+00#  1.8e-02   -1.3e-17    0.0000    f
    0.920   2.8e-02 -4.0e+00#  1.8e-02   -2.6e-18    0.0000    f
    0.962   2.8e-02 -1.7e+01#  1.8e-02   -4.2e-12    0.0000    f
    0.983   2.8e-02   9.0e-19   1.8e-02   -3.4e-11    0.0000    p
    0.972   2.8e-02 -6.5e+01#  1.8e-02   -8.7e-18    0.0000    f
    0.978   2.8e-02 -7.4e-18   1.8e-02   -1.3e-17    0.0000    p
    0.975   2.8e-02 -2.1e+02#  1.8e-02   -1.9e-11    0.0000    f
    0.976   2.8e-02 -3.9e-16   1.8e-02   -6.4e-18    0.0000    p
    0.976   2.8e-02 -4.4e+02#  1.8e-02    0.0e+00    0.0000    f

 Gamma value achieved:     0.9764
#+end_example

The high pass filter is defined as $H_H = 1 - H_L$.
#+begin_src matlab
  Hh = 1 - Hl;
#+end_src

The size of the filters is shown below.

#+begin_src matlab :exports results :results output replace :wrap example
  size(Hh), size(Hl)
#+end_src

#+RESULTS:
#+begin_example
size(Hh), size(Hl)
State-space model with 1 outputs, 1 inputs, and 27 states.
State-space model with 1 outputs, 1 inputs, and 27 states.
#+end_example

The bode plot of the obtained filters as shown on figure [[fig:hinf_synthesis_ligo_results]].

#+begin_src matlab :exports none
  figure;
  hold on;
  set(gca,'ColorOrderIndex',1)
  plot([0.0001, 0.008], [8e-3, 8e-3], ':', 'DisplayName', 'Spec. on $H_H$');
  set(gca,'ColorOrderIndex',1)
  plot([0.008 0.04], [8e-3, 1], ':', 'HandleVisibility', 'off');
  set(gca,'ColorOrderIndex',1)
  plot([0.04 0.1], [3, 3], ':', 'HandleVisibility', 'off');

  set(gca,'ColorOrderIndex',2)
  plot([0.1, 10], [0.045, 0.045], ':', 'DisplayName', 'Spec. on $H_L$');

  set(gca,'ColorOrderIndex',1)
  plot(freqs, abs(squeeze(freqresp(Hh, freqs, 'Hz'))), '-', 'DisplayName', '$H_H$');
  set(gca,'ColorOrderIndex',2)
  plot(freqs, abs(squeeze(freqresp(Hl, freqs, 'Hz'))), '-', 'DisplayName', '$H_L$');

  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('Magnitude');
  hold off;
  xlim([freqs(1), freqs(end)]);
  ylim([1e-3, 10]);
  legend('location', 'southeast');
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/hinf_synthesis_ligo_results.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:hinf_synthesis_ligo_results
#+CAPTION: Obtained complementary filters using the $\mathcal{H}_\infty$ synthesis ([[./figs/hinf_synthesis_ligo_results.png][png]], [[./figs/hinf_synthesis_ligo_results.pdf][pdf]])
[[file:figs/hinf_synthesis_ligo_results.png]]

** Compare FIR and H-Infinity Filters
Let's now compare the FIR filters designed in cite:hua05_low_ligo and the one obtained with the $\mathcal{H}_\infty$ synthesis on figure [[fig:comp_fir_ligo_hinf]].

#+begin_src matlab :exports none
  figure;
  hold on;
  set(gca,'ColorOrderIndex',1)
  plot(freqs, abs(squeeze(freqresp(Hh, freqs, 'Hz'))), '-', 'DisplayName', '$\mathcal{H}_\infty$ filters');
  set(gca,'ColorOrderIndex',2)
  plot(freqs, abs(squeeze(freqresp(Hl, freqs, 'Hz'))), '-', 'HandleVisibility', 'off');

  set(gca,'ColorOrderIndex',1)
  plot(w, abs(H), '--', 'DisplayName', 'FIR filters')
  set(gca,'ColorOrderIndex',2)
  plot(w, abs(1-H), '--', 'HandleVisibility', 'off')

  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('Magnitude');
  hold off;
  xlim([freqs(1), freqs(end)]);
  ylim([1e-3, 10]);

  legend('location', 'northeast');
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/comp_fir_ligo_hinf.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:comp_fir_ligo_hinf
#+CAPTION: Comparison between the FIR filters developped for LIGO and the $\mathcal{H}_\infty$ complementary filters ([[./figs/comp_fir_ligo_hinf.png][png]], [[./figs/comp_fir_ligo_hinf.pdf][pdf]])
[[file:figs/comp_fir_ligo_hinf.png]]

** Using Analytical Formula                                       :noexport:
#+begin_src matlab
  alpha = 0.5;
  beta = 5;
  w0 = 2*pi*0.045;

  Hh_ana = (s/w0)^3 * ((s/w0)^2 + (1+alpha+beta)*(s/w0) + (1+(alpha+1)*(beta+1)))/((s/w0 + 1)*((s/w0)^2+alpha*(s/w0)+1)*((s/w0)^2+beta*(s/w0)+1));
  Hl_ana = ((1+(alpha+1)*(beta+1))*(s/w0)^2 + (1+alpha+beta)*(s/w0) + 1)/((s/w0 + 1)*((s/w0)^2+alpha*(s/w0)+1)*((s/w0)^2+beta*(s/w0)+1));
#+end_src

#+begin_src matlab :exports none
  figure;
  hold on;
  set(gca,'ColorOrderIndex',1)
  plot(freqs, abs(squeeze(freqresp(Hh_ana, freqs, 'Hz'))), '-');
  set(gca,'ColorOrderIndex',1)
  plot([0.0001, 0.008], [8e-3, 8e-3], ':');
  set(gca,'ColorOrderIndex',1)
  plot([0.008 0.04], [8e-3, 1], ':');
  set(gca,'ColorOrderIndex',1)
  plot([0.04 0.1], [3, 3], ':');

  set(gca,'ColorOrderIndex',2)
  plot([0.1, 10], [0.1, 0.1], ':');
  set(gca,'ColorOrderIndex',2)
  plot(freqs, abs(squeeze(freqresp(Hl_ana, freqs, 'Hz'))), '-');

  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  xlabel('Frequency [Hz]'); ylabel('Magnitude');
  hold off;
  xlim([freqs(1), freqs(end)]);
  ylim([1e-4, 10]);
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/ligo_analytical_formula_comp_filters.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:ligo_analytical_formula_comp_filters
#+CAPTION: Obtained complementary filters using the analytical formula ([[./figs/ligo_analytical_formula_comp_filters.png][png]], [[./figs/ligo_analytical_formula_comp_filters.pdf][pdf]])
[[file:figs/ligo_analytical_formula_comp_filters.png]]
* Analytical Formula found in the literature
  <<sec:analytical_formula_literature>>

** Analytical Formula
cite:min15_compl_filter_desig_angle_estim
\begin{align*}
  H_L(s) = \frac{K_p s + K_i}{s^2 + K_p s + K_i} \\
  H_H(s) = \frac{s^2}{s^2 + K_p s + K_i}
\end{align*}

cite:corke04_inert_visual_sensin_system_small_auton_helic
\begin{align*}
  H_L(s) = \frac{1}{s/p + 1} \\
  H_H(s) = \frac{s/p}{s/p + 1}
\end{align*}

cite:jensen13_basic_uas
\begin{align*}
  H_L(s) = \frac{2 \omega_0 s + \omega_0^2}{(s + \omega_0)^2} \\
  H_H(s) = \frac{s^2}{(s + \omega_0)^2}
\end{align*}

\begin{align*}
  H_L(s) = \frac{C(s)}{C(s) + s} \\
  H_H(s) = \frac{s}{C(s) + s}
\end{align*}

cite:shaw90_bandw_enhan_posit_measur_using_measur_accel
\begin{align*}
  H_L(s) = \frac{3 \tau s + 1}{(\tau s + 1)^3} \\
  H_H(s) = \frac{\tau^3 s^3 + 3 \tau^2 s^2}{(\tau s + 1)^3}
\end{align*}

cite:baerveldt97_low_cost_low_weigh_attit
\begin{align*}
  H_L(s) = \frac{2 \tau s + 1}{(\tau s + 1)^2} \\
  H_H(s) = \frac{\tau^2 s^2}{(\tau s + 1)^2}
\end{align*}

** Matlab Init                                              :noexport:ignore:
#+begin_src matlab :tangle no :exports none :results silent :noweb yes :var current_dir=(file-name-directory buffer-file-name)
  <<matlab-dir>>
#+end_src

#+begin_src matlab :exports none :results silent :noweb yes
  <<matlab-init>>
#+end_src

** Matlab
#+begin_src matlab
  omega0 = 1*2*pi; % [rad/s]
  tau = 1/omega0; % [s]

  % From cite:corke04_inert_visual_sensin_system_small_auton_helic
  HL1 = 1/(s/omega0 + 1); HH1 = s/omega0/(s/omega0 + 1);

  % From cite:jensen13_basic_uas
  HL2 = (2*omega0*s + omega0^2)/(s+omega0)^2; HH2 = s^2/(s+omega0)^2;

  % From cite:shaw90_bandw_enhan_posit_measur_using_measur_accel
  HL3 = (3*tau*s + 1)/(tau*s + 1)^3; HH3 = (tau^3*s^3 + 3*tau^2*s^2)/(tau*s + 1)^3;
#+end_src

#+begin_src matlab :exports none
  freqs = logspace(-1, 1, 1000);

  figure;
  % Magnitude
  ax1 = subaxis(2,1,1);
  hold on;
  set(gca,'ColorOrderIndex',1); plot(freqs, abs(squeeze(freqresp(HH1, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',1); plot(freqs, abs(squeeze(freqresp(HL1, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',2); plot(freqs, abs(squeeze(freqresp(HH2, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',2); plot(freqs, abs(squeeze(freqresp(HL2, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',3); plot(freqs, abs(squeeze(freqresp(HH3, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',3); plot(freqs, abs(squeeze(freqresp(HL3, freqs, 'Hz'))));
  set(gca, 'XScale', 'log'); set(gca, 'YScale', 'log');
  set(gca, 'XTickLabel',[]);
  ylabel('Magnitude');
  hold off;
  ylim([1e-2 2]);
  % Phase
  ax2 = subaxis(2,1,2);
  hold on;
  set(gca,'ColorOrderIndex',1); plot(freqs, 180/pi*angle(squeeze(freqresp(HH1, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',1); plot(freqs, 180/pi*angle(squeeze(freqresp(HL1, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',2); plot(freqs, 180/pi*angle(squeeze(freqresp(HH2, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',2); plot(freqs, 180/pi*angle(squeeze(freqresp(HL2, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',3); plot(freqs, 180/pi*angle(squeeze(freqresp(HH3, freqs, 'Hz'))));
  set(gca,'ColorOrderIndex',3); plot(freqs, 180/pi*angle(squeeze(freqresp(HL3, freqs, 'Hz'))));
  set(gca,'xscale','log');
  yticks(-180:90:180);
  ylim([-180 180]);
  xlabel('Relative Frequency $\frac{\omega}{\omega_0}$'); ylabel('Phase [deg]');
  hold off;
  linkaxes([ax1,ax2],'x');
  xlim([freqs(1), freqs(end)]);
#+end_src

#+HEADER: :tangle no :exports results :results none :noweb yes
#+begin_src matlab :var filepath="figs/comp_filters_literature.pdf" :var figsize="full-tall" :post pdf2svg(file=*this*, ext="png")
  <<plt-matlab>>
#+end_src

#+NAME: fig:comp_filters_literature
#+CAPTION: Comparison of some complementary filters found in the literature ([[./figs/comp_filters_literature.png][png]], [[./figs/comp_filters_literature.pdf][pdf]])
[[file:figs/comp_filters_literature.png]]

** Discussion
Analytical Formula found in the literature provides either no parameter for tuning the robustness / performance trade-off.

* Comparison of the different methods of synthesis
  <<sec:discussion>>
The generated complementary filters using $\mathcal{H}_\infty$ and the analytical formulas are very close to each other. However there is some difference to note here:
- the analytical formula provides a very simple way to generate the complementary filters (and thus the controller), they could even be used to tune the controller online using the parameters $\alpha$ and $\omega_0$. However, these formula have the property that $|H_H|$ and $|H_L|$ are symmetrical with the frequency $\omega_0$ which may not be desirable.
- while the $\mathcal{H}_\infty$ synthesis of the complementary filters is not as straightforward as using the analytical formula, it provides a more optimized procedure to obtain the complementary filters
* Bibliography                                                       :ignore:
bibliographystyle:unsrt
bibliography:ref.bib
